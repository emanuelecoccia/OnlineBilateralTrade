import numpy as np
import pandas as pd
from typing import Tuple

class DummyEnvironment:
    def __init__(self, T:int)->None:
        """
        This class is a dummy environment that generates a sequence of valuations.
        The sequence is generated by sampling at random points (0, 1/4), (3/4, 1) from a bernoulli distribution.
        """
        self.T = T
        # Determine the valuation sequence beforehand
        self.valuation_sequence = self.construct_valuation_sequence()

    def construct_valuation_sequence(self)->np.ndarray:
        # Sample at random points (0, 1/4), (3/4, 1) from a bernoulli distribution
        left_point = np.array([0, 1/4])
        right_point = np.array([3/4, 1])
        points = np.vstack([left_point, right_point])
        valuation_sequence_indices = np.random.choice(2, size=self.T)
        valuation_sequence = points[valuation_sequence_indices]
        return valuation_sequence
    
    def get_valuations(self, index)->np.ndarray:
        # Return the feedback
        return self.valuation_sequence[index]
    
    def get_best_expert(self)->Tuple[Tuple[float, float], float]:
        """
        This function computes the aggregated reward on the unit square and returns 
        the price pair "under" which the reward is maximized.

        Complexity: O(T^2).
        """
        # Work with pandas for easier sorting
        df = pd.DataFrame(self.valuation_sequence, columns=['s', 'b'])

        # Sort the price pairs by b in descending order and s in ascending order
        sorted_df = df.sort_values(by=['b', 's'], ascending=[False, True]) # might be redundant

        # Eliminate all the price pairs with b <= s
        filtered_df = sorted_df[sorted_df['b'] >= sorted_df['s']]

        # Group by b
        grouped = filtered_df.groupby('b')

        # Get sorted group keys in descending order
        sorted_keys = sorted(grouped.groups.keys(), reverse=True)

        prev_curr_rewards = []
        max_reward = 0
        max_reward_tuple = (0, 0)

        for b in sorted_keys:
            group = grouped.get_group(b)
            reward_index = 0
            baseline_reward = 0
            reward_max_index = len(prev_curr_rewards) - 1 
            curr_rewards = []

            # Iterate through the s values
            for s in group['s']:
                if prev_curr_rewards: # if the list is not empty
                    # Swipe through prev_s < s
                    while reward_index <= reward_max_index:
                        s_prev, reward_prev = prev_curr_rewards[reward_index]
                        if s > s_prev:
                            new_reward = reward_prev + baseline_reward
                            # Append the curr_rewards before s
                            curr_rewards.append((s_prev, new_reward))
                            reward_index += 1
                            # Update max reward
                            if new_reward > max_reward:
                                max_reward = new_reward
                                max_reward_tuple = (s_prev, b)
                        elif s == s_prev:
                            if reward_index > 0:
                                baseline_reward += reward_prev - prev_curr_rewards[reward_index-1][1]
                            else:
                                baseline_reward += reward_prev
                        else:
                            break

                # Increment the baseline reward with the current s
                baseline_reward += b-s
                # If the current s is the same as the previous s, update the reward
                if curr_rewards and s == curr_rewards[-1][0]:
                    curr_rewards[-1] = (s, baseline_reward)
                else:
                    if prev_curr_rewards:
                        reward_s  = prev_curr_rewards[reward_index][1] + baseline_reward
                    else:
                        reward_s = baseline_reward
                    curr_rewards.append((s, reward_s))
                # Update max reward
                if reward_s > max_reward:
                    max_reward = reward_s
                    max_reward_tuple = (s, b)

            # Swipe through prev_s > s if prev_s < b
            if prev_curr_rewards:
                while reward_index <= reward_max_index:
                    s_prev, reward_prev = prev_curr_rewards[reward_index]
                    if reward_index <= reward_max_index and s_prev <= b:
                        new_reward = reward_prev + baseline_reward
                        curr_rewards.append((s_prev, new_reward))
                        reward_index += 1
                        # Update max reward
                        if new_reward > max_reward:
                            max_reward = new_reward
                            max_reward_tuple = (s_prev, b)
                    else:
                        break
            
            # print(curr_rewards) # Debugging
            prev_curr_rewards = curr_rewards

        return max_reward_tuple, max_reward